# -*- coding: utf-8 -*-
"""Psych420Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1JCbIHBm2vLaUqDQ0ZqpkOQWpW1jM31Fc
"""

#================================================
# Final Project
# PSYCH 420
# Wasam Syed (20746474) & Riad Dajani (20816768)
#================================================



import scipy.io as si
import numpy as np
import matplotlib.pyplot as plt
import random as r
from scipy import fftpack as fftpack
from scipy import signal as sig
import statistics

# Google colab does not have the mouse library installed
# pip3 install mouse was the command used to install the library
# import mouse

# The data_range can be varied from 100 to 38401 (representing 2.5 minutes in
# the original dataset). channel_number ranges from 1-64 representing 
# all the electrodes according to the original datasets assignment and 

data_range = 1000
time_step = 0.004
channel_number = 25
c_ind = channel_number-1

# https://github.com/mastaneht/SPIS-Resting-State-Dataset/tree/master/Pre-SART%20EEG link to dataset
# Unfortunately the data needs to be downloaded and referenced locally

mat_cl_1 = si.loadmat("/S02_restingPre_EC.mat")
mat_open_1 = si.loadmat("/S02_restingPre_EO.mat")

# Random weight generation

def weights(ran = data_range):
    ans = np.array([])
    wi = 0.00
    for elem in range(ran):
        wi = round(r.uniform(0.01,0.1), 2)
        ans = np.insert(ans,elem,wi)
    return ans
    
wts = weights()  

# DATA EXTRACTION

ys_cl = mat_cl_1['dataRest'].tolist()
ys_open = mat_open_1['dataRest'].tolist()
ts = [elem for elem in range(data_range)]

main_data_cl = ys_cl[c_ind][0:data_range]
main_data_open = ys_open[c_ind][0:data_range]

# Created this specifically for the Power Spectral Density Spectrum

def occipital_data(d, r=data_range):
  ans_dict = {
      'O1': d[26][0:r],
      'O2': d[63][0:r],
      'Oz': d[28][0:r],
      'PO7':d[24][0:r],
      'PO3':d[25][0:r],
      'POz':d[29][0:r],
      'PO8':d[61][0:r],
      'PO4':d[62][0:r]
  }
  return ans_dict

moc_02 = occipital_data(d = ys_cl)
mop_02 = occipital_data(d = ys_open)
  

# DATA ANALYSIS

#Standard Deviation
cl_mean = statistics.mean(main_data_cl)    
cl_sd = statistics.stdev(main_data_cl)

open_mean = statistics.mean(main_data_open)    
open_sd = statistics.stdev(main_data_open)

# Collect data points from occipital lobe sensor and standardizing
cl_final = [((elem - cl_mean)) for elem in main_data_cl]
open_final = [((elem - open_mean)) for elem in main_data_open]

def delta(ins, wts, thresh = 3, lr = 0.1):
    I = sum([i*w for i, w in zip(ins,wts)])
    observed = 1 if I > thresh else 0
    new_wts = [((observed-1)*lr)*i + w for i, w in zip(ins,wts)]
    return new_wts


# Plotting the standardized graph to show noise in signal
plt.figure()
plt.plot(ts, cl_final, label = "Closed")
plt.plot(ts, open_final, label = "Open")
plt.ylabel("P.D. (V)")
plt.xlabel("Time (s)")
plt.suptitle("Final")
plt.legend()
plt.show()

# Significant difference in means used to classify
print(open_mean-cl_mean)
print(cl_mean)
print(open_mean)

# DATA CLEANING

# Example of signal noise reduction based on the following video
# https://youtu.be/b06pFMIRO0I

# Creating the Fourier Transformed Signal
eeg_fft = fftpack.fft(np.asarray(cl_final))

# Extracting Amplitude, Power and Angle of the signal
Amp_eeg = np.abs(eeg_fft)
Pow_eeg = Amp_eeg ** 2
Ang_eeg = np.angle(eeg_fft)

sample_freq_eeg = fftpack.fftfreq(np.asarray(cl_final).size)
Amp_Freq_eeg = np.array([Amp_eeg, sample_freq_eeg])
Amp_pos_eeg = Amp_Freq_eeg[0,:].argmax()
peak_freq_eeg = Amp_Freq_eeg[1, Amp_pos_eeg]

hf_fft = eeg_fft.copy()
hf_fft[np.abs(sample_freq_eeg) > peak_freq_eeg] = 0
filtered_eeg = fftpack.ifft(hf_fft)

plt.figure()
plt.plot(ts, eeg_fft)
plt.show()

plt.figure()
plt.plot(ts, filtered_eeg)
plt.show()

filt_fft_eeg = fftpack.fft(filtered_eeg)

Amp_filt_eeg = np.abs(filt_fft_eeg)
Pow_filt_eeg = Amp_filt_eeg ** 2
Ang_filt_eeg = np.angle(filt_fft_eeg)

sample_freq_eeg_filt = fftpack.fftfreq(filt_fft_eeg.size)
Amp_Freq_eeg_filt = np.array([Amp_filt_eeg, sample_freq_eeg_filt])
Amp_pos_filt_eeg = Amp_Freq_eeg_filt[0,:].argmax()
peak_freq_filt_eeg = Amp_Freq_eeg_filt[1, Amp_pos_filt_eeg]

# Filtered graph
# Single frequency

plt.figure()
plt.plot(Amp_Freq_eeg_filt[1], Amp_Freq_eeg_filt[0])
plt.show()


print(Amp_pos_filt_eeg)

# FEATURE EXTRACTION

Fs = 256
freq_cl_02, wel_eeg_cl_02 = sig.welch(moc_02['O1'], Fs, scaling='spectrum')
freq_open_02, wel_eeg_open_02 = sig.welch(mop_02['O1'], Fs, scaling='spectrum')

plt.semilogy(freq_cl_02[0:40], wel_eeg_cl_02[0:40], label = 'Closed')
plt.semilogy(freq_open_02[0:40], wel_eeg_open_02[0:40], label='Open')
plt.xlabel('frequency (Hz)')
plt.ylabel('PSD')
plt.legend()
plt.grid()
plt.show()

# CLASSIFICATION

# Backprop Proof of concept (data from eeg goes in, and can identify state by useing mean as classifier)
X = np.array(([-1872.0034589823335, 1], [-1872.0034589823335, 2], [9568.017679248005, 3], [-9568.017679248005, 4]), dtype=float)
Y = np.array(([1], [1], [0], [0]), dtype=float)

X = X/np.amax(X, axis=0)

class NN(object):
	def __init__(self):
		self.inputSize = 2
		self.outputSize = 1
		self.hiddenLayer = 3

		self.W1 = np.random.randn(self.inputSize, self.hiddenLayer)
		self.W2 = np.random.randn(self.hiddenLayer, self. outputSize)

	def cost(self, X, Y):
		self.yH = self.fforward(X)
		return sum((Y-self.yH)**2)*1/2

	def costP(self, X, Y):
		self.yH = self.fforward(X)
		d3 = np.multiply(-(Y-self.yH), self.sigP(self.z3))
		costW2 = np.dot(self.a2.T, d3)
		d2 = np.dot(d3, self.W2.T)*self.sigP(self.z2)
		costW1 = np.dot(X.T, d2)
		return costW1, costW2

	def sig(self, z):
		return 1/(1+np.exp(-z))

	def sigP(self, z):
		return np.exp(-z)/((1+np.exp(-z))**2)

	def fforward(self, x):
		self.z2 = np.dot(x, self.W1)
		self.a2 = self.sig(self.z2)
		self.z3 = np.dot(self.a2, self.W2)
		yH = self.sig(self.z3)
		return yH

NN = NN()
error = []
iteration = []
for i in range(1000):
	J1 = NN.cost(X, Y)
	t = 3
	costW1, costW2 = NN.costP(X, Y)
	NN.W1 = NN.W1 - t*costW1
	NN.W2 = NN.W2 - t*costW2
	J2 = NN.cost(X,Y)
	costW1, costW2 = NN.costP(X, Y)
	NN.W1 = NN.W1 - t*costW1
	NN.W2 = NN.W2 - t*costW2
	J3 = NN.cost(X,Y) 

	yH = NN.fforward(X)
	error.append(J3)
	iteration.append(i)
	if (i == 1000):
		break

print(np.round(yH, 2))
mp.plot(iteration, error)
mp.show()

# APPLICATION

# The following snippet of code moves the mouse up if the output of the 
# perceptron is True i.e., the eyes are open.

# Commented out to prevent program from crashing

"""
def move_mouse(op):
  if (inp == 1):
    mouse.move(0, -1000, absolute=False, duration=0.01)
  else:
    mouse.move(0, 1000, absolute=False, duration=0.01)
"""